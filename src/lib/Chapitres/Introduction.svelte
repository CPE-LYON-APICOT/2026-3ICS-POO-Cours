<script lang="ts">
	import Code from '$lib/deck/code.svelte'
	import PlantUml from '$lib/deck/plantUml.svelte'
	import Slide from '$lib/deck/slide.svelte'
	import ProgProceduraleSchema from '$lib/Seance1/ProgProceduraleSchema.svelte'   
	import ProgOOSchema from '$lib/Seance1/ProgOOSchema.svelte'
</script>
	
<!-- svelte-ignore a11y-missing-attribute -->
<!-- svelte-ignore a11y-invalid-attribute -->
<Slide>
	<Slide><h1>Introduction</h1></Slide>
	
	<!-- ACCROCHE : La question fondamentale -->
	<Slide>
		<h2>
			La <span data-fragment-index="1" class="fragment highlight-red">Programmation</span> Orient√©e Objet
		</h2>
		<p data-fragment-index="1" class="fragment">La programmation, c'est manipuler des donn√©es...</p>
		<p data-fragment-index="2" class="fragment">
			<i>Comment structurer ces donn√©es et les traitements associ√©s ?</i>
		</p>
		<aside class="notes">
			On commence par poser la question fondamentale. Peu importe le langage, peu importe le projet, 
			on manipule toujours des donn√©es. La vraie question c'est : comment on organise tout √ßa ?
		</aside>
	</Slide>

	<!-- ANNONCE DU PLAN : Les 3 piliers -->
	<Slide>
		<h2>La POO en 3 mots</h2>
		<div class="flex flex-row justify-around items-center text-3xl mt-10">
			<div class="fragment flex flex-col items-center p-6 bg-accent-950 rounded-lg">
				<span class="text-6xl mb-4">üì¶</span>
				<span class="text-important font-bold">RANGER</span>
				<span class="text-xl mt-2 text-gray-400">Organiser le code</span>
			</div>
			<div class="fragment flex flex-col items-center p-6 bg-accent-950 rounded-lg">
				<span class="text-6xl mb-4">üîí</span>
				<span class="text-important font-bold">PROT√âGER</span>
				<span class="text-xl mt-2 text-gray-400">√âviter les erreurs</span>
			</div>
			<div class="fragment flex flex-col items-center p-6 bg-accent-950 rounded-lg">
				<span class="text-6xl mb-4">üå≥</span>
				<span class="text-important font-bold">G√âN√âRALISER</span>
				<span class="text-xl mt-2 text-gray-400">R√©utiliser le code</span>
			</div>
		</div>
		<aside class="notes">
			On va voir que la POO apporte 3 b√©n√©fices majeurs, dans cet ordre pr√©cis. 
			D'abord on range, ensuite on prot√®ge, et enfin on g√©n√©ralise.
			Ces 3 piliers sont la base de tout ce qu'on va voir dans ce module.
		</aside>
	</Slide>

	<!-- ============================================ -->
	<!-- PILIER 1 : RANGER -->
	<!-- ============================================ -->
	
	<Slide data_background_color="#1a1a2e">
		<h2 class="text-6xl">üì¶ RANGER</h2>
		<p class="text-3xl text-gray-400">Premier pilier de la POO</p>
		<aside class="notes">
			On commence par le premier pilier : ranger. C'est le plus intuitif.
		</aside>
	</Slide>

	<Slide>
		<h3>Le probl√®me du code "en vrac"</h3>
		<Code>
			{`
// Des variables partout...
string nomClient = "Jean";
int ageClient = 25;
string emailClient = "jean@mail.com";

string nomProduit = "Ordinateur";
double prixProduit = 999.99;
int stockProduit = 42;

string nomVendeur = "Marie";
string emailVendeur = "marie@shop.com";

// Et des fonctions qui utilisent tout √ßa...
envoyerFacture(nomClient, emailClient, nomProduit, prixProduit);
notifierVendeur(emailVendeur, nomClient, nomProduit);
`}
		</Code>
		<aside class="notes">
			Regardez ce code. On a des variables partout, m√©lang√©es. 
			Rien ne dit que nomClient va avec ageClient et emailClient.
			Quand le code grossit, c'est le chaos. On ne sait plus quelle variable va avec quelle autre.
		</aside>
	</Slide>

	<Slide>
		<h3>La solution : regrouper dans des objets</h3>
		<Code lines="1-5|7-11|13-16|18-20">
			{`
class Client {
    string nom;
    int age;
    string email;
}

class Produit {
    string nom;
    double prix;
    int stock;
}

class Vendeur {
    string nom;
    string email;
}

Client jean = new Client("Jean", 25, "jean@mail.com");
Produit ordi = new Produit("Ordinateur", 999.99, 42);
Vendeur marie = new Vendeur("Marie", "marie@shop.com");
`}
		</Code>
		<aside class="notes">
			Avec la POO, on regroupe ce qui va ensemble. Un Client a un nom, un √¢ge, un email.
			Un Produit a un nom, un prix, un stock. Chaque "bo√Æte" contient ce qui lui appartient.
			C'est d√©j√† plus clair, non ?
		</aside>
	</Slide>

	<Slide>
		<div class="grid-cols-2 grid justify-items-center items-start">
			<h3>Programmation proc√©durale</h3>
			<h3 data-fragment-index="1" class="fragment">Programmation orient√©e objet</h3>
			<ProgProceduraleSchema />
			<div data-fragment-index="1" class="fragment">
				<ProgOOSchema />
			</div>
		</div>
		<aside class="notes">
			Visuellement, c'est √ßa la diff√©rence. √Ä gauche, les donn√©es sont s√©par√©es des traitements.
			Les fonctions peuvent acc√©der √† n'importe quelle donn√©e.
			√Ä droite, chaque objet contient SES donn√©es ET SES traitements.
			C'est une vraie bo√Æte autonome.
		</aside>
	</Slide>

	<Slide>
		<div class="grid-cols-2 grid justify-items-center items-start">
			<h3>Programmation proc√©durale</h3>
			<h3>Programmation orient√©e objet</h3>
			<ul>
				<li>Les donn√©es et les traitements sont s√©par√©s</li>
				<li class="fragment">Les fonctions acc√®dent √† <span class="text-red-400">tout</span></li>
				<li class="fragment">Difficile de savoir "qui fait quoi"</li>
			</ul>
			<ul>
				<li>Les donn√©es et les traitements sont regroup√©s dans un objet</li>
				<li class="fragment">Les m√©thodes n'acc√®dent qu'√† <span class="text-green-400">leur objet</span></li>
				<li class="fragment">Chaque objet est responsable de lui-m√™me</li>
			</ul>
		</div>
		<p class="fragment font-bold text-accent-200 mt-8">Premier int√©r√™t : le code est mieux organis√©</p>
		<aside class="notes">
			En proc√©dural, les fonctions peuvent acc√©der √† tout. C'est pratique au d√©but, mais √ßa devient vite le bazar.
			En POO, chaque objet est une entit√© autonome. Il g√®re ses propres donn√©es avec ses propres m√©thodes.
			C'est le premier b√©n√©fice : on range, on organise.
		</aside>
	</Slide>

	<!-- ============================================ -->
	<!-- PILIER 2 : PROT√âGER -->
	<!-- ============================================ -->

	<Slide data_background_color="#1a1a2e">
		<h2 class="text-6xl">üîí PROT√âGER</h2>
		<p class="text-3xl text-gray-400">Deuxi√®me pilier de la POO</p>
		<aside class="notes">
			Maintenant qu'on a rang√©, on va voir le deuxi√®me pilier : prot√©ger.
			C'est l√† que la POO devient vraiment puissante.
		</aside>
	</Slide>

	<Slide>
		<h3>Le probl√®me : les erreurs silencieuses</h3>
		<p>En proc√©dural, rien ne vous emp√™che de faire n'importe quoi...</p>
		<Code class="java">
			{`
string nomPersonne1 = "Jean";
int agePersonne1 = 25;
string nomPersonne2 = "Marie";
int agePersonne2 = 30;

// La fonction attend (nom, age) mais...
void direBonjour(string nom, int valeur) {
    print("Bonjour " + nom + ", vous avez " + valeur + " ans");
}

direBonjour(nomPersonne1, agePersonne1);  // ‚úÖ OK : "Bonjour Jean, vous avez 25 ans"
direBonjour(nomPersonne1, agePersonne2);  // üêõ Compile... mais BUG !
// "Bonjour Jean, vous avez 30 ans" ‚Üí C'est l'√¢ge de Marie !
`}
		</Code>
		<aside class="notes">
			Regardez ce code. La fonction direBonjour attend un nom et un √¢ge.
			Mais rien ne m'emp√™che de lui passer l'√¢ge de Marie √† la place de celui de Jean !
			Le code compile, il s'ex√©cute... mais le r√©sultat est faux.
			C'est un bug silencieux, le pire type de bug.
		</aside>
	</Slide>

	<Slide>
		<h3>Le probl√®me empire avec le temps...</h3>
		<Code class="java" lines="1-8|10-15">
			{`
// 6 mois plus tard, le code a grossi...
string nomClient = "Jean";
string nomProduit = "Ordinateur";
string nomVendeur = "Marie";
int ageClient = 25;
int stockProduit = 42;
int ancienneteVendeur = 5;
double prixProduit = 999.99;

// Quelle variable va avec quelle autre ?
// C'est quoi le 2√®me param√®tre d√©j√† ?
envoyerFacture(nomClient, /* ??? */, prixProduit);
calculerRemise(ageClient, /* ou ancienneteVendeur ? */, prixProduit);
notifierStock(nomProduit, stockProduit, /* emailClient ou emailVendeur ? */);
`}
		</Code>
		<p class="fragment text-red-400 font-bold">Plus le code grossit, plus on se trompe !</p>
		<aside class="notes">
			6 mois plus tard, vous avez 50 variables, 30 fonctions.
			Vous ne savez plus quelle variable va avec quelle autre.
			Vous vous trompez de param√®tre, le code compile, mais √ßa ne marche pas.
			Vous passez des heures √† d√©bugger.
		</aside>
	</Slide>

	<Slide>
		<h3>La solution POO : impossible de se tromper</h3>
		<Code class="java" lines="1-11|13-17">
			{`
class Personne {
    string nom;    // Appartient √† Personne
    int age;       // Appartient √† Personne
    
    void direBonjour() {
        // Utilise UNIQUEMENT les donn√©es de CET objet
        print("Bonjour " + nom + ", vous avez " + age + " ans");
        // Impossible d'utiliser une variable ext√©rieure ici !
        // Elle n'existe pas dans Personne
    }
}

Personne jean = new Personne("Jean", 25);
Personne marie = new Personne("Marie", 30);

jean.direBonjour();   // ‚úÖ Utilise jean.nom et jean.age
marie.direBonjour();  // ‚úÖ Utilise marie.nom et marie.age
`}
		</Code>
		<aside class="notes">
			En POO, la m√©thode direBonjour est DANS l'objet Personne.
			Elle ne prend pas de param√®tres, elle utilise directement les donn√©es de l'objet.
			Chaque personne a sa propre m√©thode qui utilise SES donn√©es.
			Impossible de m√©langer les donn√©es de Jean et Marie.
		</aside>
	</Slide>

	<Slide>
		<h3>Comparaison directe</h3>
		<div class="grid-cols-2 grid justify-items-center items-start gap-4">
			<div>
				<h4 class="text-red-400">‚ùå Proc√©dural</h4>
				<Code class="java">
					{`
//
direBonjour(nom1, age1);  // OK
direBonjour(nom1, age2);  // BUG !
// Rien ne m'emp√™che de m√©langer
`}
				</Code>
			</div>
			<div>
				<h4 class="text-green-400">‚úÖ POO</h4>
				<Code class="java">
					{`
//
jean.direBonjour();
marie.direBonjour();
// Chacun utilise SES donn√©es
`}
				</Code>
			</div>
		</div>
		<p class="fragment text-accent-200 font-bold text-3xl mt-8">
			Les m√©thodes ne manipulent que les donn√©es de LEUR objet
		</p>
		<aside class="notes">
			C'est √ßa la vraie puissance. En proc√©dural, vous pouvez m√©langer les donn√©es de personnes diff√©rentes.
			En POO, chaque m√©thode n'acc√®de qu'aux donn√©es de son objet.
			Jean utilise les donn√©es de Jean, Marie utilise les donn√©es de Marie. Impossible de se tromper.
		</aside>
	</Slide>

	<Slide>
		<h3>Exemple complet : avant / apr√®s</h3>
		<div class="grid-cols-2 grid justify-items-center items-start">
			<h4>Proc√©dural</h4>
			<h4 class="fragment" data-fragment-index="1">Orient√© Objet</h4>
			<Code class="java">
				{`
string nom = "Jean";
int age = 25;
string nom2 = "Pierre";
int age2 = 30;

void direBonjour(string n, int a){
    print("Bonjour " + n 
        + ", vous avez " + a + " ans");
}

direBonjour(nom, age);
direBonjour(nom2, age2);
// direBonjour(nom, age2); // Bug !
`}
			</Code>
			<Code class="java fragment" data-fragment-index="1" lines="1-9|10-13">
				{`
class Personne {
    string nom;
    int age;
    
    void direBonjour(){
        print("Bonjour " + nom 
            + ", vous avez " + age + " ans");
    }
}
Personne p1 = new Personne("Jean", 25);
Personne p2 = new Personne("Pierre", 30);
p1.direBonjour();  // Utilise p1.nom, p1.age
p2.direBonjour();  // Utilise p2.nom, p2.age
`}
			</Code>
		</div>
		<aside class="notes">
			√Ä gauche, on pourrait se tromper et appeler direBonjour avec nom et age2. Bug silencieux.
			√Ä droite, chaque Personne est un objet autonome. 
			Quand on appelle p1.direBonjour(), c'est TOUJOURS les donn√©es de p1 qui sont utilis√©es.
			Impossible de m√©langer.
		</aside>
	</Slide>

	<Slide>
		<h3>R√©capitulatif : Ranger + Prot√©ger</h3>
		<div class="flex flex-row justify-around items-start mt-8">
			<div class="p-6 bg-accent-950 rounded-lg">
				<h4 class="text-important">üì¶ RANGER</h4>
				<ul class="text-2xl">
					<li>Donn√©es regroup√©es par entit√©</li>
					<li>Code plus lisible</li>
					<li>Plus facile √† maintenir</li>
				</ul>
			</div>
			<div class="p-6 bg-accent-950 rounded-lg">
				<h4 class="text-important">üîí PROT√âGER</h4>
				<ul class="text-2xl">
					<li>M√©thodes li√©es √† leurs donn√©es</li>
					<li>Impossible de se tromper de param√®tre</li>
					<li>Le compilateur vous aide</li>
				</ul>
			</div>
		</div>
		<p class="fragment text-3xl mt-8">Mais ce n'est pas tout...</p>
		<aside class="notes">
			On a vu les deux premiers piliers. On range le code, on le prot√®ge des erreurs.
			Mais la POO offre un troisi√®me b√©n√©fice, peut-√™tre le plus puissant : la g√©n√©ralisation.
		</aside>
	</Slide>

	<!-- ============================================ -->
	<!-- PILIER 3 : G√âN√âRALISER -->
	<!-- ============================================ -->

	<Slide data_background_color="#1a1a2e">
		<h2 class="text-6xl">üå≥ G√âN√âRALISER</h2>
		<p class="text-3xl text-gray-400">Troisi√®me pilier de la POO</p>
		<aside class="notes">
			Le troisi√®me pilier, c'est la g√©n√©ralisation. C'est l√† qu'on va parler d'h√©ritage, d'abstraction.
			C'est ce qui rend la POO vraiment unique.
		</aside>
	</Slide>

	<Slide>
		<h2>La programmation orient√©e objet</h2>
		<h3>Qu'est-ce que c'est ?</h3>
		<p>
			La programmation orient√©e objet est un <span class="text-important">paradigme de programmation</span>, 
			c'est-√†-dire une mani√®re de programmer, qui repose sur la notion d'objets.
		</p>
		<p class="fragment">
			Un objet est une entit√© qui regroupe des donn√©es et des traitements qui lui sont associ√©s.
		</p>
		<p class="fragment">Un objet est cens√© repr√©senter <span class="text-important">une entit√© du monde r√©el</span>.</p>
		<p class="fragment text-accent-200 font-bold">Il n'est pas obligatoire de programmer en POO !</p>
		<aside class="notes">
			La POO c'est un paradigme, une fa√ßon de penser le code.
			L'id√©e c'est de mod√©liser le monde r√©el : des personnes, des voitures, des produits...
			Ce n'est pas obligatoire, mais c'est tr√®s puissant quand on sait s'en servir.
		</aside>
	</Slide>

	<Slide>
		<h3>Repr√©senter le monde r√©el</h3>
		<p class="font-bold text-accent-200">
			Un objet est cens√© repr√©senter une entit√© du monde r√©el.
		</p>
		<p class="fragment" data-fragment-index="2">
			Par exemple, <span data-fragment-index="3" class="fragment highlight-red"
				>un chien, un chat</span
			>,
			<span data-fragment-index="3" class="fragment highlight-green">une moto, une voiture</span>,
			<span data-fragment-index="3" class="fragment highlight-blue">un ennemi, un PNJ</span>
		</p>
		<p class="fragment" data-fragment-index="3">
			Ou plus <span class="underline font-bold">g√©n√©riquement</span>, un
			<span class="text-red-500">animal</span>, un <span class="text-green-500">v√©hicule</span>,
			un <span class="text-blue-500">personnage</span>
		</p>
		<aside class="notes">
			On mod√©lise le monde r√©el. Un chien, un chat, ce sont des objets.
			Mais on peut aller plus loin : un chien et un chat, c'est un animal.
			Une moto et une voiture, c'est un v√©hicule.
			C'est √ßa la g√©n√©ralisation : trouver le concept commun.
		</aside>
	</Slide>

	<Slide>
		<h3>Pourquoi g√©n√©raliser ?</h3>
		<p>Imaginons que vous codez un jeu vid√©o...</p>
		<div class="grid-cols-2 grid gap-8 mt-8">
			<div class="fragment">
				<h4 class="text-red-400">‚ùå Sans g√©n√©ralisation</h4>
				<Code class="java">
					{`
class Guerrier { 
    void attaquer() {...}
    void seDeplacer() {...}
}
class Mage { 
    void attaquer() {...}
    void seDeplacer() {...}
}
class Archer { 
    void attaquer() {...}
    void seDeplacer() {...}
}
// Code dupliqu√© partout !
`}
				</Code>
			</div>
			<div class="fragment">
				<h4 class="text-green-400">‚úÖ Avec g√©n√©ralisation</h4>
				<Code class="java">
					{`
class Personnage {
    void seDeplacer() {...}
    // Code commun une seule fois
}
class Guerrier extends Personnage { 
    void attaquer() {...}
}
class Mage extends Personnage { 
    void attaquer() {...}
}
class Archer extends Personnage { 
    void attaquer() {...}
}
`}
				</Code>
			</div>
		</div>
		<aside class="notes">
			Sans g√©n√©ralisation, on duplique le code. Chaque personnage a sa m√©thode seDeplacer, m√™me si c'est la m√™me.
			Avec la g√©n√©ralisation, on met le code commun dans une classe parente.
			Si on change seDeplacer, on le change une seule fois, et tous les personnages en b√©n√©ficient.
		</aside>
	</Slide>

	<Slide>
		<h3 class="uppercase">La g√©n√©ricit√©</h3>
		<p>G√©n√©ralisez vos concepts !</p>

		<div class="tree scale-150">
			<ul>
				<li>
					<a href="#">Animal</a>
					<ul>
						<li>
							<a>Chien</a>
						</li>
						<li>
							<a>Chat</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#">V√©hicule</a>
					<ul>
						<li>
							<a>Voiture</a>
						</li>
						<li>
							<a>Moto</a>
						</li>
						<li class="fragment" data-fragment-index="1">
							<a>Bateau</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#">Personnage</a>
					<ul>
						<li>
							<a>Ennemi</a>
							<ul class="fragment" data-fragment-index="1">
								<li><a>Monstre</a></li>
								<li><a>Boss</a></li>
							</ul>
						</li>
						<li>
							<a>PNJ</a>
						</li>
					</ul>
				</li>
			</ul>
		</div>
		<aside class="notes">
			On peut repr√©senter √ßa sous forme d'arbre. Animal se d√©cline en Chien et Chat.
			V√©hicule se d√©cline en Voiture, Moto, et pourquoi pas Bateau demain.
			Personnage se d√©cline en Ennemi et PNJ, et Ennemi peut lui-m√™me se d√©cliner en Monstre et Boss.
			C'est ce qu'on appelle l'h√©ritage : les enfants h√©ritent des caract√©ristiques du parent.
		</aside>
	</Slide>

	<Slide>
		<h3>L'h√©ritage : le c≈ìur de la POO</h3>
		<p>Quand <code>Voiture</code> h√©rite de <code>V√©hicule</code> :</p>
		<ul class="text-2xl">
			<li class="fragment">‚úÖ Elle r√©cup√®re automatiquement toutes les donn√©es de V√©hicule</li>
			<li class="fragment">‚úÖ Elle r√©cup√®re automatiquement toutes les m√©thodes de V√©hicule</li>
			<li class="fragment">‚úÖ Elle peut ajouter ses propres donn√©es (nbPortes, nbPlaces...)</li>
			<li class="fragment">‚úÖ Elle peut modifier le comportement h√©rit√© si besoin</li>
		</ul>
		<p class="fragment text-accent-200 font-bold mt-8">
			√âcrivez le code une fois, r√©utilisez-le partout !
		</p>
		<aside class="notes">
			L'h√©ritage c'est √ßa : on √©crit le code une fois dans le parent, et tous les enfants en b√©n√©ficient.
			Si on ajoute un attribut "couleur" √† V√©hicule, Voiture et Moto l'ont automatiquement.
			C'est un gain de temps √©norme, et surtout, moins de bugs car moins de code dupliqu√©.
		</aside>
	</Slide>
	<Slide>
		<h3 class="uppercase">L'abstraction : penser au futur</h3>
		<p>
			En POO, g√©n√©raliser s'appelle <span class="text-important"
				>abstraire, faire une abstraction</span
			>
		</p>
		<p class="fragment">C'est anticiper les √©volutions de votre code.</p>
		<aside class="notes">
			Abstraire, c'est trouver le concept commun entre plusieurs choses.
			Mais c'est aussi penser au futur : qu'est-ce que mon client va me demander demain ?
		</aside>
	</Slide>

	<Slide>
		<h3 class="uppercase">Exemple concret : location de voiture</h3>
		<p class="text-start text-[28px] p-4 bg-accent-950 font-serif rounded-lg">
			<span class="text-important">Situation :</span> On vous demande de coder un syst√®me de location de voiture.<br/><br/>
			<span class="fragment">üìÖ <b>6 mois plus tard :</b> "On aimerait aussi proposer des motos !"</span><br/>
			<span class="fragment">üìÖ <b>1 an plus tard :</b> "Et des v√©los √©lectriques !"</span><br/>
			<span class="fragment">üìÖ <b>2 ans plus tard :</b> "Et des accessoires : si√®ges auto, porte-v√©los, cha√Ænes neige..."</span>
		</p>
		<p class="fragment text-accent-200 font-bold mt-6">
			Si vous aviez anticip√©, vous auriez cod√© "V√©hicule" d√®s le d√©part !
		</p>
		<aside class="notes">
			C'est un sc√©nario classique. On vous demande de g√©rer des voitures, mais √©videmment, 
			√ßa va √©voluer. Motos, v√©los, accessoires...
			Si vous codez "Voiture" partout, vous allez devoir tout refaire.
			Si vous codez "V√©hicule" d√®s le d√©part, ajouter une Moto c'est 5 minutes.
		</aside>
	</Slide>

	<Slide>
		<h3 class="uppercase">Le pi√®ge du code non g√©n√©ralis√©</h3>
		<Code class="java">
			{`
// Code na√Øf : tout est sp√©cifique √† Voiture
class Voiture {
    double prixJour;
    boolean disponible;
    int km;
    String immatriculation;
    int nbPortes;      // Sp√©cifique Voiture
    int nbPlaces;      // Sp√©cifique Voiture
}

// Gestion de location
void louerVoiture(Voiture v, Client c) {...}
void retournerVoiture(Voiture v) {...}
double calculerPrixVoiture(Voiture v, int nbJours) {...}
`}
		</Code>
		<p class="fragment text-red-400 font-bold">
			Demain on ajoute les motos... on doit tout dupliquer ? üò±
		</p>
		<aside class="notes">
			Voil√† le pi√®ge. On a cod√© tout autour de Voiture.
			Si on veut ajouter Moto, il faut cr√©er louerMoto, retournerMoto, calculerPrixMoto...
			C'est du code dupliqu√©, c'est des bugs, c'est un cauchemar.
		</aside>
	</Slide>

	<Slide>
		<h3 class="uppercase">√âtape 1 : Cr√©er la hi√©rarchie V√©hicule</h3>
		<p>On commence par regrouper Voiture et Moto sous V√©hicule</p>
		<PlantUml>
			{`
			@startuml
			!theme crt-amber
			skinparam backgroundColor transparent
			abstract class Vehicule {		
				+ double prixJour
				+ boolean disponible
				+ int km
				+ String immatriculation
				+ void louer()
				+ void retourner()
			}
			class Voiture {
				+ int nbPortes
				+ int nbPlaces
			}
			class Moto {
				+ int cylindree
			}
			Vehicule <|-- Voiture
			Vehicule <|-- Moto
			@enduml
			`}
		</PlantUml>
		<p class="fragment text-accent-200">
			<b>Voiture</b> est un <b>V√©hicule</b> ‚Üí elle h√©rite de prixJour, disponible, louer()...
		</p>
		<aside class="notes">
			Premi√®re √©tape : on cr√©e V√©hicule qui contient tout ce qui est commun.
			Voiture et Moto h√©ritent de V√©hicule. 
			Donc Voiture EST UN V√©hicule. Elle a automatiquement prixJour, disponible, km, immatriculation.
			Elle a aussi les m√©thodes louer() et retourner() sans les recoder.
		</aside>
	</Slide>

	<Slide>
		<h3 class="uppercase">√âtape 2 : Ajouter les Accessoires</h3>
		<p>Les accessoires ont aussi un prix et une disponibilit√©...</p>
		<div class="flex flex-row justify-center items-start gap-8">
			<PlantUml>
				{`
			@startuml
			!theme crt-amber
			skinparam backgroundColor transparent
			abstract class Vehicule {		
				+ double prixJour
				+ boolean disponible
				+ int km
				+ String immatriculation
			}
			class Voiture {
				+ int nbPortes
			}
			class Moto {
				+ int cylindree
			}
			Vehicule <|-- Voiture
			Vehicule <|-- Moto
			@enduml
			`}
			</PlantUml>
			<PlantUml>
				{`
			@startuml
			!theme crt-amber
			skinparam backgroundColor transparent
			abstract class Accessoire {
				+ double prixJour
				+ boolean disponible
				+ String identifiant
			}
			class SiegeAuto {
				+ int ageMax
			}
			class PorteVelo {
				+ int nbPlaces
			}
			Accessoire <|-- SiegeAuto
			Accessoire <|-- PorteVelo
			@enduml
			`}
			</PlantUml>
		</div>
		<p class="fragment text-red-400 font-bold mt-4">
			‚ö†Ô∏è prixJour et disponible sont dupliqu√©s dans V√©hicule ET Accessoire !
		</p>
		<aside class="notes">
			On ajoute les accessoires. Si√®geAuto et PorteVelo h√©ritent de Accessoire.
			Mais attendez... prixJour et disponible sont dans V√©hicule ET dans Accessoire.
			C'est de la duplication ! On peut faire mieux.
		</aside>
	</Slide>

	<Slide>
		<h3 class="uppercase">√âtape 3 : Abstraire encore plus avec Louable</h3>
		<p>V√©hicule et Accessoire ont des points communs ‚Üí on cr√©e <span class="text-important">Louable</span></p>
		<PlantUml>
			{`
			@startuml
			!theme crt-green
			skinparam backgroundColor transparent
			abstract class Louable{
				+ double prixJour
				+ boolean disponible
				+ void louer()
				+ void retourner()
				+ double calculerPrix(int nbJours)
			}
			abstract class Vehicule extends Louable{		
				+ int km
				+ String immatriculation
			}
			class Voiture {
				+ int nbPortes
				+ int nbPlaces
			}
			class Moto {
				+ int cylindree
			}
			Vehicule <|-- Voiture
			Vehicule <|-- Moto

			abstract class Accessoire extends Louable {
				+ String identifiant
			}
			class SiegeAuto {
				+ int ageMax
			}
			class PorteVelo {
				+ int nbPlaces
			}
			Accessoire <|-- SiegeAuto
			Accessoire <|-- PorteVelo
			
			@enduml
			`}
		</PlantUml>
		<aside class="notes">
			On cr√©e Louable qui contient prixJour, disponible, et les m√©thodes louer, retourner, calculerPrix.
			V√©hicule h√©rite de Louable, et Accessoire aussi.
			Du coup Voiture h√©rite de V√©hicule qui h√©rite de Louable : Voiture a TOUT !
		</aside>
	</Slide>

	<Slide>
		<h3 class="uppercase">Visualisons la cha√Æne d'h√©ritage</h3>
		<p>Une <b>Voiture</b> c'est quoi maintenant ?</p>
		<div class="flex flex-col items-center mt-8 text-2xl">
			<div class="fragment p-4 bg-green-950 rounded-lg mb-2">
				<b>Voiture</b> h√©rite de <b>V√©hicule</b>
			</div>
			<div class="fragment text-4xl">‚Üì</div>
			<div class="fragment p-4 bg-blue-950 rounded-lg mb-2">
				<b>V√©hicule</b> h√©rite de <b>Louable</b>
			</div>
			<div class="fragment text-4xl">‚Üì</div>
			<div class="fragment p-4 bg-accent-950 rounded-lg">
				Donc <b>Voiture</b> a : prixJour, disponible, louer(), retourner(), km, immatriculation, nbPortes, nbPlaces
			</div>
		</div>
		<p class="fragment text-accent-200 font-bold mt-6">
			On n'a cod√© louer() qu'une seule fois, dans Louable !
		</p>
		<aside class="notes">
			Suivons la cha√Æne. Voiture h√©rite de V√©hicule. V√©hicule h√©rite de Louable.
			Donc Voiture a tout : les attributs de Louable, plus ceux de V√©hicule, plus les siens.
			Et surtout, la m√©thode louer() n'est cod√©e qu'une seule fois, dans Louable.
			Voiture, Moto, Si√®geAuto, PorteVelo... tous peuvent √™tre lou√©s avec le m√™me code !
		</aside>
	</Slide>

	<Slide>
		<h3 class="uppercase">Le code devient simple</h3>
		<Code class="java">
			{`
// Une seule m√©thode pour TOUT louer !
void louer(Louable item, Client c) {
    item.louer();
    // Fonctionne pour Voiture, Moto, SiegeAuto, PorteVelo...
}

// Ajouter un v√©lo √©lectrique demain ?
class VeloElectrique extends Vehicule {
    int autonomieKm;
}
// C'est tout ! Il h√©rite automatiquement de louer(), retourner()...
`}
		</Code>
		<p class="fragment text-green-400 font-bold">
			‚úÖ Une seule m√©thode pour tout louer<br/>
			‚úÖ Ajouter un nouveau type = quelques lignes<br/>
			‚úÖ Z√©ro duplication de code
		</p>
		<aside class="notes">
			Regardez la puissance. Une seule m√©thode louer() qui fonctionne pour tout.
			Demain on ajoute VeloElectrique ? 3 lignes de code. Il h√©rite de tout le reste.
			C'est √ßa la vraie puissance de la POO : √©crire moins, faire plus.
		</aside>
	</Slide>
	<Slide data_background_color="#00353F">
		<h3 class="uppercase">Le refactoring</h3>
		<p>
			L'op√©ration que l'on vient de voir s'appelle un <span class="text-important">refactoring</span>
		</p>
		<p class="fragment">C'est r√©organiser le code sans changer son comportement.</p>
		<p class="fragment">
			Si vous l'aviez fait d√®s le d√©part, vous auriez gagn√© plus de temps que si vous devez le faire
			plus tard, c'est une <u>certitude</u> !
		</p>
		<aside class="notes">
			Le refactoring, c'est am√©liorer la structure du code sans changer ce qu'il fait.
			C'est toujours plus facile de bien faire d√®s le d√©but que de r√©parer apr√®s.
			Un code bien con√ßu, c'est des heures de debug en moins.
		</aside>
	</Slide>

	<Slide data_background_color="#00353F">
		<h3 class="uppercase">BUILD vs RUN</h3>
		<p class="text-important">
			Le temps d'impl√©mentation (BUILD) augmente si vous faites beaucoup de POO
		</p>
		<p class="fragment">...mais la maintenance (RUN) co√ªte moins cher !</p>
		<div class="fragment grid grid-cols-2 gap-8 mt-8">
			<div class="p-4 bg-red-950 rounded-lg">
				<h4 class="text-red-400">‚ùå Code vite fait</h4>
				<ul class="text-xl">
					<li>Rapide √† √©crire</li>
					<li>Difficile √† maintenir</li>
					<li>Bugs fr√©quents</li>
					<li>√âvolutions co√ªteuses</li>
				</ul>
			</div>
			<div class="p-4 bg-green-950 rounded-lg">
				<h4 class="text-green-400">‚úÖ Code bien con√ßu</h4>
				<ul class="text-xl">
					<li>Plus long √† √©crire</li>
					<li>Facile √† maintenir</li>
					<li>Moins de bugs</li>
					<li>√âvolutions simples</li>
				</ul>
			</div>
		</div>
		<aside class="notes">
			En entreprise, on parle de BUILD (le d√©veloppement initial) et de RUN (la maintenance).
			Un code bien con√ßu co√ªte plus cher au BUILD mais beaucoup moins au RUN.
			Et le RUN, c'est souvent 80% du co√ªt total d'un projet !
		</aside>
	</Slide>

	<Slide data_background_color="#00353F">
		<h3 class="uppercase">L'√©quilibre √† trouver</h3>
		<p>Un <i>bon</i> ing√©nieur logiciel sait jusqu'√† quel niveau il convient d'abstraire</p>
		<ul class="mt-8">
			<li class="fragment">‚ùå <b>Pas assez d'abstraction :</b> vous devez tout casser pour ajouter une fonctionnalit√©</li>
			<li class="fragment">‚ùå <b>Trop d'abstraction :</b> votre client paie pour du code qu'il n'utilisera jamais</li>
		</ul>
		<p class="fragment mt-8">
			En entreprise, tout est question d'√©quilibre et vient avec l'exp√©rience.
		</p>
		<aside class="notes">
			C'est un √©quilibre √† trouver. Pas assez d'abstraction, et chaque √©volution est un cauchemar.
			Trop d'abstraction, et vous passez des semaines √† coder des trucs inutiles.
			√áa vient avec l'exp√©rience, avec les projets, avec les erreurs qu'on fait.
		</aside>
	</Slide>

	<Slide data_background_color="#00353F">
		<h3 class="uppercase">Dans ce module</h3>
		<p class="text-important text-4xl">
			Faites le plus de z√®le possible, exag√©rez !
		</p>
		<p class="fragment mt-8 text-2xl">
			C'est en allant trop loin qu'on apprend o√π sont les limites.
		</p>
		<p class="fragment text-2xl">
			Vous apprendrez √† doser en entreprise, avec de vrais projets et de vraies contraintes.
		</p>
		<aside class="notes">
			Dans ce module, je vous encourage √† en faire trop. Abstraire partout, h√©riter de tout.
			C'est comme √ßa qu'on apprend o√π sont les limites.
			En entreprise, vous aurez des contraintes de temps, de budget. L√†, vous apprendrez √† doser.
			Ici, c'est le moment d'exp√©rimenter.
		</aside>
	</Slide>

	<!-- ============================================ -->
	<!-- CONCLUSION -->
	<!-- ============================================ -->

	<Slide>
		<h2>R√©capitulatif</h2>
		<div class="flex flex-row justify-around items-start mt-8">
			<div class="fragment p-4 bg-accent-950 rounded-lg">
				<h4 class="text-important">üì¶ RANGER</h4>
				<p class="text-xl">Donn√©es + m√©thodes<br/>dans un m√™me objet</p>
			</div>
			<div class="fragment p-4 bg-accent-950 rounded-lg">
				<h4 class="text-important">üîí PROT√âGER</h4>
				<p class="text-xl">Chaque m√©thode n'acc√®de<br/>qu'√† son objet</p>
			</div>
			<div class="fragment p-4 bg-accent-950 rounded-lg">
				<h4 class="text-important">üå≥ G√âN√âRALISER</h4>
				<p class="text-xl">H√©ritage et abstraction<br/>pour r√©utiliser le code</p>
			</div>
		</div>
		<aside class="notes">
			On r√©capitule. La POO c'est 3 piliers.
			Ranger : on met ensemble ce qui va ensemble.
			Prot√©ger : chaque m√©thode ne touche qu'√† son objet, le compilateur vous aide.
			G√©n√©raliser : on √©crit le code une fois, on le r√©utilise partout gr√¢ce √† l'h√©ritage.
		</aside>
	</Slide>

	<Slide>
		<h3>La POO, c'est quoi au final ?</h3>
		<p class="fragment">
			Vous venez d'√™tre confront√© aux concepts fondamentaux de la POO :
		</p>
		<ul class="fragment text-2xl mt-4">
			<li><span class="text-important">L'encapsulation</span> : ranger et prot√©ger les donn√©es</li>
			<li><span class="text-important">L'abstraction</span> : g√©n√©raliser les concepts</li>
			<li><span class="text-important">L'h√©ritage</span> : r√©utiliser le code des parents</li>
		</ul>
		<p class="fragment mt-8">Nous allons voir ces concepts en d√©tail dans les chapitres suivants.</p>
		<aside class="notes">
			On a vu les bases. Encapsulation, abstraction, h√©ritage.
			Ce sont les piliers de la POO, et on va les approfondir tout au long du module.
			Chaque chapitre va d√©tailler un de ces concepts.
		</aside>
	</Slide>

	<Slide>
		<h3>Retenez ceci</h3>
		<p>
			La POO est un <span class="text-important">"outil"</span>. 
		</p>
		<p class="fragment">
			Si vous faites du Java, m√™me en codant mal, vous faites de la POO 
			compte tenu de la nature du langage.
		</p>
		<p class="fragment mt-8 text-2xl bg-accent-950 p-4 rounded-lg">
			Si la programmation n'est qu'une suite de blocs de code tels des <b>l√©gos</b>, 
			la POO, c'est fabriquer des blocs <span class="text-important">intelligemment</span> 
			que vous r√©utilisez, peu importe que vous construisiez un pont ou une maison.
		</p>
		<aside class="notes">
			La POO c'est un outil, pas une obligation. Mais c'est un outil puissant.
			En Java, vous faites de la POO que vous le vouliez ou non, c'est la nature du langage.
			L'id√©e c'est de fabriquer des briques r√©utilisables. Comme des l√©gos bien con√ßus.
			Une brique "V√©hicule" peut servir pour une voiture aujourd'hui, une moto demain, un vaisseau spatial dans 5 ans.
		</aside>
	</Slide>

	<Slide>
		<h2>√Ä vous de jouer !</h2>
		<p class="text-3xl mt-8">Dans les prochains chapitres, nous allons :</p>
		<ul class="text-2xl mt-4">
			<li class="fragment">üì¶ Approfondir l'<b>encapsulation</b> et la visibilit√©</li>
			<li class="fragment">üîó Ma√Ætriser l'<b>h√©ritage</b> et le polymorphisme</li>
			<li class="fragment">üìã D√©couvrir les <b>interfaces</b> et les classes abstraites</li>
			<li class="fragment">üé® Apprendre les <b>Design Patterns</b> classiques</li>
		</ul>
		<aside class="notes">
			C'est parti pour la suite ! On va approfondir chaque concept.
			L'encapsulation, l'h√©ritage, les interfaces, et m√™me les Design Patterns.
			√Ä la fin du module, vous saurez concevoir du code propre, √©volutif, maintenable.
		</aside>
	</Slide>
</Slide>